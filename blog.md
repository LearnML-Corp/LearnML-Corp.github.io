## Blog page

[Back to startpage](/index.md)

## July 17, 2022 - [English] - Post#2 - What the idea behind coding interviews is, why they are often misused and what they have to do on GitHub.

The coding interview is a very common term in IT, there are countless videos on YouTube about this topic and many discussions, both positive and negative. But why is there so much negative criticism of these coding interviews and are they actually, as so often criticized, so often used incorrectly?

To answer this, I would first like to look at the original idea behind coding interviews:

Coding interviews are supposed to be used to assess potential candidates for a job in the IT industry.
Originally this idea was introduced by Microsoft in the 1990s and later adopted by the big FAANG corporations.

The purpose of these is to test the ability to solve problems and especially the creativity of the candidates, usually done on a white board or e.g. in GoogleDocs and not in a special code editor. These problems are intended to divide a large number of candidates into two smaller sets: 
1. possible candidates 2. rejected candidates.

The questions were posed in such a way that the whole thing was mostly more like a puzzle and the pure problem solving ability and creativity of the candidate was
was tested.

Nowadays, however, one notices that coding interviews are moving further and further away from this original idea. So it is no longer primarily about the ability to solve the given problem with creativity, but only to solve a list of the most common algorithms for the already classic interview questions and often unchanging basic concepts by heart and just adapt them to the given problem. This is not even a bad thing, because these algorithms are a highly optimized way to solve these problems and can be adapted and used for a wide range of problems.

However, the use of the coding algorithms should also be adapted accordingly. FAANG groups are concerned with processing countless amounts of data as efficiently as possible, and this is possible with the help of these standard algorithms. Thus, the very best are "filtered out" of the countless, mostly highly qualified applicants for a job, because it is an efficient, standardized way to deal with a large number of highly qualified applicants and to be able to clearly refer to something.

However, a big problem nowadays is that the concept of coding interviews is copied by most IT companies from the big FAANG companies and is usually not adapted to the size of the company or number of applicants, but is conducted in the same style. It can seem a bit ridiculous if a small startup with few applicants holds the same coding interviews as a huge corporation with countless applicants, whereas such a screening of candidates with standardized problems is not necessary at all. 

It would be much more appropriate to hold an interview tailored to the open position in order to be able to make a decision. However, only in the case of several applicants for one position and a clear decision between two candidates cannot be made on the basis of their references. Not by default with every single applicant.

This also leads me to my second point, that even some smaller GitHub projects are starting to hold coding interviews by default, where it is simply unnecessary to hold one and the few applicants are reduced even more or even the only applicant is rejected due to an unresolved interview question. And here the question really arises is this still a proper use of coding interviews? The answer is a clear no, because this is not about screening out a large number of applicants. But how would a proper use of coding interviews look like in this case? 

There are two possibilities, either to simply leave the interview alone, as it is an inappropriate measure and time-consuming without real success. The second possibility is a clearly adapted coding interview, which aims to get to know the mostly completely unknown applicants, to test their communication and to roughly check their coding style as well as their creativity and ability to fill exactly this "position".
It should not matter whether the applicant can invert a binary tree or not. It should be tested, if the person can think himself into the own project and can work on problems, which can occur in the real project in a suitable way. It is not primarily important whether the person can solve the problem or not. Such problems are usually solved in a team and in GitHub projects usually not under time pressure. Therefore, the only focus here should be on their communication skills and their ability to get into problems and work on them. So just a way to get to know applicants a little better and primarily make sure that all team members feel comfortable and communication between them is okay.

As a small conclusion, coding interviews are an excellent way to select applicants and make sense for large corporations, but are often used incorrectly for smaller companies or even GitHub projects.

I hope you enjoyed my post and I was able to give you a better understanding of my view on this topic. See you in the next post!

---

## July 17, 2022 - [English] - Post#1 - Adaptability vs. self-optimization vs. learning ability - Is there even a difference?

I recently had a conversation with a friend about the topic of artificial intelligence and quite quickly the obligatory question arose as to what exactly one actually understands by intelligence. At first, the term intelligence seems to be completely clear, so clear that one usually just uses it intuitively and never really thinks about what it actually means.

However, when we talk about artificial intelligence, this very question comes up quite quickly and we realize that there seems to be no clear definition at all. In computer science, the term Artificial Intelligence has long been replaced by the term Machine Learning for modern processes. Thus, in this case, intelligence is clearly assumed to be "capable of learning". Now, however, the discussion was by no means over at this point. If one now searches online for a definition of the term Artificial Intelligence or Machine Learning, it becomes clear that the elusive term intelligence is simply assigned various definitions, each of which characterizes partial aspects of this large term. Three major sub-areas are usually mentioned: 1. learning ability, 2. adaptability, 3. self-optimization.

At first glance, these sound plausible, since they summarize or cover many aspects of intelligence well. And that was with my friend and me also first the case, we had found three beautiful terms the term intelligence beautifully describe and in each case a seperaten subrange to describe. But the terms are very similar and during further discussion the question came up, don't these three terms describe one and the same process? Is it even possible to distinguish between them in applications?

Consider, for example, the following case from life. One is a pupil/student at a school/university and there is an exam coming up and one asks oneself, how much should I study for this exam? So the first sentence would be: "You would be stupid not to learn a lot for this exam!", which means in reverse it would be intelligent to learn a lot to achieve a good result. However, there are people who have to learn much less than others to achieve the same result. Here it becomes clear, there must be a structural prerequisite, which makes different learning ability/quickness possible. Thus the following connection arises: "Who can learn better/faster is simply more intelligent!" Now, one may agree or disagree with this, but that would raise a major issue of its own.

However, if one comes back to our discussion and considers the above case under the 2nd aspect adaptability, an equation with the term learning ability becomes indispensable. So the following is reality in most cases: "One learns purely nothing for the examination and gets in the system of the grading a bad mark to the consequence; if one learns now for the examination then one gets a clearly better mark, depending upon learning expenditure".

And now the two terms can be excellently equated: "An intelligent person would now realize that he should adapt to the system in order to be able to achieve the maximum success, also via the detour of converting a negative experience into a positive reaction; now one can start right here and say that one learns from bad experiences and adapts or learns ways to achieve better results. Thus, learning and adaptation describe very similar processes and are very similar in their results. Thereby both adaptation and learning can be the consequence of the other process and form a chain."

If one takes now the third term to the hand, the "self-optimization", one sees quite easily that also this one is only a form of the adaptability and represents at the same time a learning process, which goes hand in hand with a process of adaptation and thereby all three processes only in subtleties to be distinguished, and/or differently to be understood can. In conclusion, however, it becomes clear that all these processes, which at first glance appear to be similar but are clearly different, cannot be distinguished at all on closer examination and in most parts even correspond to each other and form one process.

Thus the final result of our common discussion was the Erkenntniss quite differently. Thus it became clear that for the term intelligence a definition alone is simply not sufficient, however a collection at definitions produces a quite clear picture. If one looks now, as in the above case, at these definitions somewhat more exactly, it is noticeable with apparently different aspects however that these are to be distinguished in most cases not at all and describe only one process.

If you have made it to the end of this post, I hope that you enjoyed it and that you could take something away from this confused discussion, since it is admittedly really a confused and very complex topic.

---